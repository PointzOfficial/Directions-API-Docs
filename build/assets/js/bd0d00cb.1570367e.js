"use strict";(self.webpackChunkpointz_api_doc=self.webpackChunkpointz_api_doc||[]).push([[8154],{423:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>l,toc:()=>d});var i=t(5893),o=t(1151);const s={sidebar_position:2},r="Decode a route shape",l={id:"decoding-shape",title:"Decode a route shape",description:"Pointz routing services use an encoded polyline format to store a series of latitude, longitude coordinates as a single string. Polyline encoding greatly reduces the size of the route response or map-matching request, especially for longer routes or GPS traces. A description is found here: polyline encoding.",source:"@site/docs/decoding-shape.md",sourceDirName:".",slug:"/decoding-shape",permalink:"/Pointz-Api-Doc-Web/docs/decoding-shape",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Directions API",permalink:"/Pointz-Api-Doc-Web/docs/direction-api"},next:{title:"Map Matching API",permalink:"/Pointz-Api-Doc-Web/docs/map-maping-api"}},a={},d=[{value:"JavaScript",id:"javascript",level:2},{value:"C++ 11",id:"c-11",level:2},{value:"Python",id:"python",level:2},{value:"R",id:"r",level:2},{value:"Go",id:"go",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",strong:"strong",...(0,o.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"decode-a-route-shape",children:"Decode a route shape"}),"\n",(0,i.jsxs)(n.p,{children:["Pointz routing services use an encoded polyline format to store a series of latitude, longitude coordinates as a single string. Polyline encoding greatly reduces the size of the route response or map-matching request, especially for longer routes or GPS traces. A description is found here: ",(0,i.jsx)(n.a,{href:"https://developers.google.com/maps/documentation/utilities/polylinealgorithm",children:"polyline encoding"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Note: Pointz APIs use six digits of decimal precision."})}),"\n",(0,i.jsx)(n.p,{children:"It is very important that you use six digits, rather than five as referenced in the Google algorithms documentation. With fewer than six digits, your locations are incorrectly placed (commonly, in the middle of an ocean), and you may receive errors with your API requests."}),"\n",(0,i.jsxs)(n.p,{children:["Below are some sample algorithms to decode the string to create a list of latitude,longitude coordinates. Using this ",(0,i.jsx)(n.a,{href:"http://valhalla.github.io/demos/polyline/",children:"demo tool"}),", you can also paste an encoded polyline string, decode it, and see the locations on a map (and save to GeoJSON). Use it to test and verify that your points are placed where you expected them."]}),"\n",(0,i.jsx)(n.h2,{id:"javascript",children:"JavaScript"}),"\n",(0,i.jsx)(n.p,{children:"Here is an example of decoding in JavaScript."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// This is adapted from the implementation in Project-OSRM\n// https://github.com/DennisOSRM/Project-OSRM-Web/blob/master/WebContent/routing/OSRM.RoutingGeometry.js\npolyline.decode = function(str, precision) {\n    var index = 0,\n        lat = 0,\n        lng = 0,\n        coordinates = [],\n        shift = 0,\n        result = 0,\n        byte = null,\n        latitude_change,\n        longitude_change,\n        factor = Math.pow(10, precision || 6);\n\n    // Coordinates have variable length when encoded, so just keep\n    // track of whether we've hit the end of the string. In each\n    // loop iteration, a single coordinate is decoded.\n    while (index < str.length) {\n\n        // Reset shift, result, and byte\n        byte = null;\n        shift = 0;\n        result = 0;\n\n        do {\n            byte = str.charCodeAt(index++) - 63;\n            result |= (byte & 0x1f) << shift;\n            shift += 5;\n        } while (byte >= 0x20);\n\n        latitude_change = ((result & 1) ? ~(result >> 1) : (result >> 1));\n\n        shift = result = 0;\n\n        do {\n            byte = str.charCodeAt(index++) - 63;\n            result |= (byte & 0x1f) << shift;\n            shift += 5;\n        } while (byte >= 0x20);\n\n        longitude_change = ((result & 1) ? ~(result >> 1) : (result >> 1));\n\n        lat += latitude_change;\n        lng += longitude_change;\n\n        coordinates.push([lat / factor, lng / factor]);\n    }\n\n    return coordinates;\n};\n\n"})}),"\n",(0,i.jsx)(n.p,{children:"Or"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'var polyline = require(\'@mapbox/polyline\');\n\n// returns an array of lat, lon pairs\npolyline.decode(\'_p~iF~ps|U_ulLnnqC_mqNvxq`@\');\n\n// returns an array of lat, lon pairs from polyline6 by passing a precision parameter\npolyline.decode(\'cxl_cBqwvnS|Dy@ogFyxmAf`IsnA|CjFzCsHluD_k@hi@ljL\', 6);\n\n// returns a GeoJSON LineString Geometry\npolyline.toGeoJSON(\'_p~iF~ps|U_ulLnnqC_mqNvxq`@\');\n\n// returns a string-encoded polyline (from coordinate ordered lat,lng)\npolyline.encode([[38.5, -120.2], [40.7, -120.95], [43.252, -126.453]]);\n\n// returns a string-encoded polyline from a GeoJSON LineString\npolyline.fromGeoJSON({ "type": "Feature",\n  "geometry": {\n    "type": "LineString",\n    "coordinates": [[-120.2, 38.5], [-120.95, 40.7], [-126.453, 43.252]]\n  },\n  "properties": {}\n});\n\n'})}),"\n",(0,i.jsx)(n.h2,{id:"c-11",children:"C++ 11"}),"\n",(0,i.jsx)(n.p,{children:"Here is an example of decoding in C++11"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c++",children:"#include <vector>\n\nconstexpr double kPolylinePrecision = 1E6;\nconstexpr double kInvPolylinePrecision = 1.0 / kPolylinePrecision;\n\nstruct PointLL {\n  float lat;\n  float lon;\n};\n\nstd::vector<PointLL> decode(const std::string& encoded) {\n  size_t i = 0;     // what byte are we looking at\n\n  // Handy lambda to turn a few bytes of an encoded string into an integer\n  auto deserialize = [&encoded, &i](const int previous) {\n    // Grab each 5 bits and mask it in where it belongs using the shift\n    int byte, shift = 0, result = 0;\n    do {\n      byte = static_cast<int>(encoded[i++]) - 63;\n      result |= (byte & 0x1f) << shift;\n      shift += 5;\n    } while (byte >= 0x20);\n    // Undo the left shift from above or the bit flipping and add to previous\n    // since its an offset\n    return previous + (result & 1 ? ~(result >> 1) : (result >> 1));\n  };\n\n  // Iterate over all characters in the encoded string\n  std::vector<PointLL> shape;\n  int last_lon = 0, last_lat = 0;\n  while (i < encoded.length()) {\n    // Decode the coordinates, lat first for some reason\n    int lat = deserialize(last_lat);\n    int lon = deserialize(last_lon);\n\n    // Shift the decimal point 5 places to the left\n    shape.emplace_back(static_cast<float>(static_cast<double>(lat) *\n                                          kInvPolylinePrecision),\n                       static_cast<float>(static_cast<double>(lon) *\n                                          kInvPolylinePrecision));\n\n    // Remember the last one we encountered\n    last_lon = lon;\n    last_lat = lat;\n  }\n  return shape;\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"python",children:"Python"}),"\n",(0,i.jsx)(n.p,{children:"Here is an example of decoding in Python"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python\n\nimport sys\n\n#six degrees of precision in Pointz\ninv = 1.0 / 1e6;\n\n#decode an encoded string\ndef decode(encoded):\n  decoded = []\n  previous = [0,0]\n  i = 0\n  #for each byte\n  while i < len(encoded):\n    #for each coord (lat, lon)\n    ll = [0,0]\n    for j in [0, 1]:\n      shift = 0\n      byte = 0x20\n      #keep decoding bytes until you have this coord\n      while byte >= 0x20:\n        byte = ord(encoded[i]) - 63\n        i += 1\n        ll[j] |= (byte & 0x1f) << shift\n        shift += 5\n      #get the final value adding the previous offset and remember it for the next\n      ll[j] = previous[j] + (~(ll[j] >> 1) if ll[j] & 1 else (ll[j] >> 1))\n      previous[j] = ll[j]\n    #scale by the precision and chop off long coords also flip the positions so\n    #its the far more standard lon,lat instead of lat,lon\n    decoded.append([float('%.6f' % (ll[1] * inv)), float('%.6f' % (ll[0] * inv))])\n  #hand back the list of coordinates\n  return decoded\n\nprint(decode(sys.argv[1]))\n"})}),"\n",(0,i.jsx)(n.h2,{id:"r",children:"R"}),"\n",(0,i.jsx)(n.p,{children:"Here is an example of decoding in R."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-r",children:'library(tidyverse)\n\ndecode <- function(encoded) {\n  chars <- stringr::str_split(encoded, "")[[1]]\n  lats <- vector(mode = "integer", length = 1)\n  lons <- vector(mode = "integer", length = 1)\n  i <- 0\n  \n  while (i < length(chars)){\n    shift <- 0\n    result <- 0\n    byte <- 0x20L\n    \n    while (byte >= 0x20) {  \n      i <- i + 1\n      byte <- chars[[i]] %>% utf8ToInt() - 63\n      result <- bitwOr(result, bitwAnd(byte, 0x1f) %>% bitwShiftL(shift))\n      shift <- shift + 5\n      if (byte < 0x20) break\n    }\n    \n    if (bitwAnd(result, 1)) {\n      result <- result %>% bitwShiftR(1) %>% bitwNot()\n    } else {\n      result <- result %>% bitwShiftR(1)\n    }\n    \n    lats <- c(lats, (lats[[length(lats)]] + result))\n    \n    shift <- 0\n    result <- 0\n    byte <- 10000L\n    \n    while (byte >= 0x20) {  \n      i <- i + 1\n      byte <- chars[[i]] %>% utf8ToInt() - 63\n      result <- bitwOr(result, bitwAnd(byte, 0x1f) %>% bitwShiftL(shift))\n      shift <- shift + 5\n      if (byte < 0x20) break\n    }\n    \n    if (bitwAnd(result, 1)) {\n      result <- result %>% bitwShiftR(1) %>% bitwNot()\n    } else {\n      result <- result %>% bitwShiftR(1)\n    }\n    \n    lons <- c(lons, (lons[[length(lons)]] + result))\n  }\n  \n  decoded <- tibble::tibble(lat = lats[2:length(lats)]/1000000,\n                            lng = lons[2:length(lons)]/1000000)\n  \n  return (decoded)\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"go",children:"Go"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"func decodePolyline(encoded *string, precisionOptional ...int) [][]float64 {\n\t// default to 6 digits of precision\n\tprecision := 6\n\tif len(precisionOptional) > 0 {\n\t\tprecision = precisionOptional[0]\n\t}\n\tfactor := math.Pow10(precision)\n\n\t// Coordinates have variable length when encoded, so just keep\n\t// track of whether we've hit the end of the string. In each\n\t// loop iteration, a single coordinate is decoded.\n\tlat, lng := 0, 0\n\tvar coordinates [][]float64\n\tindex := 0\n\tfor index < len(*encoded) {\n\t\t// Consume varint bits for lat until we run out\n\t\tvar byte int = 0x20\n\t\tshift, result := 0, 0\n\t\tfor byte >= 0x20 {\n\t\t\tbyte = int((*encoded)[index]) - 63\n\t\t\tresult |= (byte & 0x1f) << shift\n\t\t\tshift += 5\n\t\t\tindex++\n\t\t}\n\n\t\t// check if we need to go negative or not\n\t\tif (result & 1) > 0 {\n\t\t\tlat += ^(result >> 1)\n\t\t} else {\n\t\t\tlat += result >> 1\n\t\t}\n\n\t\t// Consume varint bits for lng until we run out\n\t\tbyte = 0x20\n\t\tshift, result = 0, 0\n\t\tfor byte >= 0x20 {\n\t\t\tbyte = int((*encoded)[index]) - 63\n\t\t\tresult |= (byte & 0x1f) << shift\n\t\t\tshift += 5\n\t\t\tindex++\n\t\t}\n\n\t\t// check if we need to go negative or not\n\t\tif (result & 1) > 0 {\n\t\t\tlng += ^(result >> 1)\n\t\t} else {\n\t\t\tlng += result >> 1\n\t\t}\n\n\t\t// scale the int back to floating point and store it\n\t\tcoordinates = append(coordinates, []float64{float64(lat) / factor, float64(lng) / factor})\n\t}\n\n\treturn coordinates\n}\n"})})]})}function h(e={}){const{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>l,a:()=>r});var i=t(7294);const o={},s=i.createContext(o);function r(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);